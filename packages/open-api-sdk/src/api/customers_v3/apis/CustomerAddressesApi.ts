/* tslint:disable */
/* eslint-disable */
/**
 * Customers V3
 * Create and manage customers.  - [Authentication](#authentication) - [Resources](#resources)  ## Authentication  Requests can be authenticated by sending an `access_token` via `X-Auth-Token` HTTP header:  ```http GET /stores/{$$.env.store_hash}/v3/customers host: api.bigcommerce.com Accept: application/json X-Auth-Token: {access_token} ```  |Header|Parameter|Description| |-|-|-| |`X-Auth-Token`|`access_token `|Obtained by creating an API account or installing an app in a BigCommerce control panel.|  ### OAuth Scopes  | UI Name                                      | Permission | Parameter                                     | |----------------------------------------------|------------|-----------------------------------------------| | Customers                                    | modify     | `store_v2_customers`                          | | Customers                                    | read-only  | `store_v2_customers_read_only`                | | Stored Payment Instruments                   | modify     | `store_stored_payment_instruments`            | | Stored Payment Instruments                   | read-only  | `store_stored_payment_instruments_read_only`  |  For more information on Authenticating BigCommerce APIs, see: [Authentication](https://developer.bigcommerce.com/api-docs/getting-started/authentication).  ## Resources * [Customer and Subscribers Overview](/api-docs/customers/customers-subscribers-overview).
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import {
    AddressCollectionResponse,
    AddressCollectionResponseFromJSON,
    AddressCollectionResponseToJSON,
    AddressCollectionResponse1,
    AddressCollectionResponse1FromJSON,
    AddressCollectionResponse1ToJSON,
    AddressPost,
    AddressPostFromJSON,
    AddressPostToJSON,
    AddressPut,
    AddressPutFromJSON,
    AddressPutToJSON,
    ErrorResponse,
    ErrorResponseFromJSON,
    ErrorResponseToJSON,
} from '../models';

export interface CustomersAddressesDeleteRequest {
    idin: Array<number>;
    accept?: string;
    contentType?: string;
}

export interface CustomersAddressesGetRequest {
    accept?: string;
    contentType?: string;
    page?: number;
    limit?: number;
    companyin?: Array<string>;
    namein?: Array<string>;
    customerIdin?: Array<number>;
    include?: CustomersAddressesGetIncludeEnum;
    idin?: Array<number>;
}

export interface CustomersAddressesPostRequest {
    addressPost: Array<AddressPost>;
    accept?: string;
    contentType?: string;
}

export interface CustomersAddressesPutRequest {
    addressPut: Array<AddressPut>;
    accept?: string;
    contentType?: string;
}

/**
 * 
 */
export class CustomerAddressesApi extends runtime.BaseAPI {

    /**
     * Deletes a Customer Address.  **Required Query** * id:in -- ID of the *Customer Address*
     * Delete a Customer Address
     */
    async customersAddressesDeleteRaw(requestParameters: CustomersAddressesDeleteRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.idin === null || requestParameters.idin === undefined) {
            throw new runtime.RequiredError('idin','Required parameter requestParameters.idin was null or undefined when calling customersAddressesDelete.');
        }

        const queryParameters: any = {};

        if (requestParameters.idin) {
            queryParameters['id:in'] = requestParameters.idin.join(runtime.COLLECTION_FORMATS["csv"]);
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
            headerParameters['Accept'] = String(requestParameters.accept);
        }

        if (requestParameters.contentType !== undefined && requestParameters.contentType !== null) {
            headerParameters['Content-Type'] = String(requestParameters.contentType);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-Auth-Token"] = this.configuration.apiKey("X-Auth-Token"); // X-Auth-Token authentication
        }

        const response = await this.request({
            path: `/customers/addresses`,
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Deletes a Customer Address.  **Required Query** * id:in -- ID of the *Customer Address*
     * Delete a Customer Address
     */
    async customersAddressesDelete(requestParameters: CustomersAddressesDeleteRequest, initOverrides?: RequestInit): Promise<void> {
        await this.customersAddressesDeleteRaw(requestParameters, initOverrides);
    }

    /**
     * Returns a list of Customer Addresses. Optional filter parameters can be passed in.
     * Get All Customer Addresses
     */
    async customersAddressesGetRaw(requestParameters: CustomersAddressesGetRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<AddressCollectionResponse>> {
        const queryParameters: any = {};

        if (requestParameters.page !== undefined) {
            queryParameters['page'] = requestParameters.page;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.companyin) {
            queryParameters['company:in'] = requestParameters.companyin.join(runtime.COLLECTION_FORMATS["csv"]);
        }

        if (requestParameters.namein) {
            queryParameters['name:in'] = requestParameters.namein.join(runtime.COLLECTION_FORMATS["csv"]);
        }

        if (requestParameters.customerIdin) {
            queryParameters['customer_id:in'] = requestParameters.customerIdin.join(runtime.COLLECTION_FORMATS["csv"]);
        }

        if (requestParameters.include !== undefined) {
            queryParameters['include'] = requestParameters.include;
        }

        if (requestParameters.idin) {
            queryParameters['id:in'] = requestParameters.idin.join(runtime.COLLECTION_FORMATS["csv"]);
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
            headerParameters['Accept'] = String(requestParameters.accept);
        }

        if (requestParameters.contentType !== undefined && requestParameters.contentType !== null) {
            headerParameters['Content-Type'] = String(requestParameters.contentType);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-Auth-Token"] = this.configuration.apiKey("X-Auth-Token"); // X-Auth-Token authentication
        }

        const response = await this.request({
            path: `/customers/addresses`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => AddressCollectionResponseFromJSON(jsonValue));
    }

    /**
     * Returns a list of Customer Addresses. Optional filter parameters can be passed in.
     * Get All Customer Addresses
     */
    async customersAddressesGet(requestParameters: CustomersAddressesGetRequest, initOverrides?: RequestInit): Promise<AddressCollectionResponse> {
        const response = await this.customersAddressesGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Creates a Customer Address. Multiple customer addresses can be created in one call.
     * Create a Customer Address
     */
    async customersAddressesPostRaw(requestParameters: CustomersAddressesPostRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<AddressCollectionResponse1>> {
        if (requestParameters.addressPost === null || requestParameters.addressPost === undefined) {
            throw new runtime.RequiredError('addressPost','Required parameter requestParameters.addressPost was null or undefined when calling customersAddressesPost.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
            headerParameters['Accept'] = String(requestParameters.accept);
        }

        if (requestParameters.contentType !== undefined && requestParameters.contentType !== null) {
            headerParameters['Content-Type'] = String(requestParameters.contentType);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-Auth-Token"] = this.configuration.apiKey("X-Auth-Token"); // X-Auth-Token authentication
        }

        const response = await this.request({
            path: `/customers/addresses`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.addressPost.map(AddressPostToJSON),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => AddressCollectionResponse1FromJSON(jsonValue));
    }

    /**
     * Creates a Customer Address. Multiple customer addresses can be created in one call.
     * Create a Customer Address
     */
    async customersAddressesPost(requestParameters: CustomersAddressesPostRequest, initOverrides?: RequestInit): Promise<AddressCollectionResponse1> {
        const response = await this.customersAddressesPostRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Updates a Customer Address. Multiple customer addresses can be updated in one call.  **Required Fields** * id -- ID of the *Customer Address* * customer_id -- ID of the *Customer*.  **Limits** * Limit of 3 concurrent requests. 
     * Update a Customer Address
     */
    async customersAddressesPutRaw(requestParameters: CustomersAddressesPutRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<AddressCollectionResponse1>> {
        if (requestParameters.addressPut === null || requestParameters.addressPut === undefined) {
            throw new runtime.RequiredError('addressPut','Required parameter requestParameters.addressPut was null or undefined when calling customersAddressesPut.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
            headerParameters['Accept'] = String(requestParameters.accept);
        }

        if (requestParameters.contentType !== undefined && requestParameters.contentType !== null) {
            headerParameters['Content-Type'] = String(requestParameters.contentType);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-Auth-Token"] = this.configuration.apiKey("X-Auth-Token"); // X-Auth-Token authentication
        }

        const response = await this.request({
            path: `/customers/addresses`,
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.addressPut.map(AddressPutToJSON),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => AddressCollectionResponse1FromJSON(jsonValue));
    }

    /**
     * Updates a Customer Address. Multiple customer addresses can be updated in one call.  **Required Fields** * id -- ID of the *Customer Address* * customer_id -- ID of the *Customer*.  **Limits** * Limit of 3 concurrent requests. 
     * Update a Customer Address
     */
    async customersAddressesPut(requestParameters: CustomersAddressesPutRequest, initOverrides?: RequestInit): Promise<AddressCollectionResponse1> {
        const response = await this.customersAddressesPutRaw(requestParameters, initOverrides);
        return await response.value();
    }

}

/**
    * @export
    * @enum {string}
    */
export enum CustomersAddressesGetIncludeEnum {
    Formfields = 'formfields'
}
