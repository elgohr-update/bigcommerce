/* tslint:disable */
/* eslint-disable */
/**
 * Content
 * Manage blog posts, blog tags, content pages, and redirects.  <div class=\"HubBlock--callout\"> <div class=\"CalloutBlock--warning\"> <div class=\"HubBlock-content\">  ### Note * Redirects V2 are deprecated; use [V3 Redirects](https://developer.bigcommerce.com/api-reference/storefront/redirects/redirects/getredirects) instead. * Pages V2 are deprecated; use [Pages V3](https://developer.bigcommerce.com/api-reference/store-management/pages) instead.   </div> </div> </div>
 *
 * The version of the OpenAPI document: 
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import {
    BlogPostBase,
    BlogPostBaseFromJSON,
    BlogPostBaseToJSON,
    BlogPostFull,
    BlogPostFullFromJSON,
    BlogPostFullToJSON,
    CountResponse,
    CountResponseFromJSON,
    CountResponseToJSON,
} from '../models';

export interface CreateABlogPostsRequest {
    accept: string;
    contentType: string;
    body: BlogPostBase;
}

export interface DeleteABlogPostRequest {
    id: number;
    accept: string;
    contentType: string;
}

export interface DeleteAllBlogPostsRequest {
    accept: string;
    contentType: string;
    page?: number;
    limit?: number;
}

export interface GetABlogPostRequest {
    id: number;
    accept: string;
    contentType: string;
}

export interface GetACountOfAllBlogPostsRequest {
    accept: string;
    contentType: string;
}

export interface GetAllBlogPostsRequest {
    accept: string;
    contentType: string;
    isPublished?: string;
    url?: string;
    tag?: string;
    publishedDate?: Date;
    page?: number;
    limit?: number;
}

export interface UpdateABlogPostRequest {
    id: number;
    accept: string;
    contentType: string;
    body: BlogPostBase;
}

/**
 * 
 */
export class BlogPostsApi extends runtime.BaseAPI {

    /**
     * Creates a *Blog Post*.  **Required Fields** *   title *   body  **Read Only Fields** *   id *   preview_url *   summary  **Notes**  * When including `published_date` in a request, supply it as a flat date string (not an object) in valid <a href=\"http://tools.ietf.org/html/rfc2822#section-3.3\" target=\"_blank\">RFC 2822</a>. The&#160;example request below includes a `published_date` in RFC 2822 format.  * Blog posts default to draft status. To publish blog posts to the storefront, set their `is_published` property to `true`. * If a custom URL is not provided, the post’s URL will be generated based on the value of `title`.
     * Create a Blog Post
     */
    async createABlogPostsRaw(requestParameters: CreateABlogPostsRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<BlogPostBase>> {
        if (requestParameters.accept === null || requestParameters.accept === undefined) {
            throw new runtime.RequiredError('accept','Required parameter requestParameters.accept was null or undefined when calling createABlogPosts.');
        }

        if (requestParameters.contentType === null || requestParameters.contentType === undefined) {
            throw new runtime.RequiredError('contentType','Required parameter requestParameters.contentType was null or undefined when calling createABlogPosts.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling createABlogPosts.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
            headerParameters['Accept'] = String(requestParameters.accept);
        }

        if (requestParameters.contentType !== undefined && requestParameters.contentType !== null) {
            headerParameters['Content-Type'] = String(requestParameters.contentType);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-Auth-Token"] = this.configuration.apiKey("X-Auth-Token"); // X-Auth-Token authentication
        }

        const response = await this.request({
            path: `/blog/posts`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: BlogPostBaseToJSON(requestParameters.body),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => BlogPostBaseFromJSON(jsonValue));
    }

    /**
     * Creates a *Blog Post*.  **Required Fields** *   title *   body  **Read Only Fields** *   id *   preview_url *   summary  **Notes**  * When including `published_date` in a request, supply it as a flat date string (not an object) in valid <a href=\"http://tools.ietf.org/html/rfc2822#section-3.3\" target=\"_blank\">RFC 2822</a>. The&#160;example request below includes a `published_date` in RFC 2822 format.  * Blog posts default to draft status. To publish blog posts to the storefront, set their `is_published` property to `true`. * If a custom URL is not provided, the post’s URL will be generated based on the value of `title`.
     * Create a Blog Post
     */
    async createABlogPosts(requestParameters: CreateABlogPostsRequest, initOverrides?: RequestInit): Promise<BlogPostBase> {
        const response = await this.createABlogPostsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Deletes a *Blog Post*.
     * Delete a Blog Post
     */
    async deleteABlogPostRaw(requestParameters: DeleteABlogPostRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling deleteABlogPost.');
        }

        if (requestParameters.accept === null || requestParameters.accept === undefined) {
            throw new runtime.RequiredError('accept','Required parameter requestParameters.accept was null or undefined when calling deleteABlogPost.');
        }

        if (requestParameters.contentType === null || requestParameters.contentType === undefined) {
            throw new runtime.RequiredError('contentType','Required parameter requestParameters.contentType was null or undefined when calling deleteABlogPost.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
            headerParameters['Accept'] = String(requestParameters.accept);
        }

        if (requestParameters.contentType !== undefined && requestParameters.contentType !== null) {
            headerParameters['Content-Type'] = String(requestParameters.contentType);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-Auth-Token"] = this.configuration.apiKey("X-Auth-Token"); // X-Auth-Token authentication
        }

        const response = await this.request({
            path: `/blog/posts/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Deletes a *Blog Post*.
     * Delete a Blog Post
     */
    async deleteABlogPost(requestParameters: DeleteABlogPostRequest, initOverrides?: RequestInit): Promise<void> {
        await this.deleteABlogPostRaw(requestParameters, initOverrides);
    }

    /**
     * Deletes a page of `Blog Posts`.
     * Delete Blog Posts
     */
    async deleteAllBlogPostsRaw(requestParameters: DeleteAllBlogPostsRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.accept === null || requestParameters.accept === undefined) {
            throw new runtime.RequiredError('accept','Required parameter requestParameters.accept was null or undefined when calling deleteAllBlogPosts.');
        }

        if (requestParameters.contentType === null || requestParameters.contentType === undefined) {
            throw new runtime.RequiredError('contentType','Required parameter requestParameters.contentType was null or undefined when calling deleteAllBlogPosts.');
        }

        const queryParameters: any = {};

        if (requestParameters.page !== undefined) {
            queryParameters['page'] = requestParameters.page;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
            headerParameters['Accept'] = String(requestParameters.accept);
        }

        if (requestParameters.contentType !== undefined && requestParameters.contentType !== null) {
            headerParameters['Content-Type'] = String(requestParameters.contentType);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-Auth-Token"] = this.configuration.apiKey("X-Auth-Token"); // X-Auth-Token authentication
        }

        const response = await this.request({
            path: `/blog/posts`,
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Deletes a page of `Blog Posts`.
     * Delete Blog Posts
     */
    async deleteAllBlogPosts(requestParameters: DeleteAllBlogPostsRequest, initOverrides?: RequestInit): Promise<void> {
        await this.deleteAllBlogPostsRaw(requestParameters, initOverrides);
    }

    /**
     * Returns a single *Blog Post*.
     * Get a Blog Post
     */
    async getABlogPostRaw(requestParameters: GetABlogPostRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<BlogPostFull>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling getABlogPost.');
        }

        if (requestParameters.accept === null || requestParameters.accept === undefined) {
            throw new runtime.RequiredError('accept','Required parameter requestParameters.accept was null or undefined when calling getABlogPost.');
        }

        if (requestParameters.contentType === null || requestParameters.contentType === undefined) {
            throw new runtime.RequiredError('contentType','Required parameter requestParameters.contentType was null or undefined when calling getABlogPost.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
            headerParameters['Accept'] = String(requestParameters.accept);
        }

        if (requestParameters.contentType !== undefined && requestParameters.contentType !== null) {
            headerParameters['Content-Type'] = String(requestParameters.contentType);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-Auth-Token"] = this.configuration.apiKey("X-Auth-Token"); // X-Auth-Token authentication
        }

        const response = await this.request({
            path: `/blog/posts/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => BlogPostFullFromJSON(jsonValue));
    }

    /**
     * Returns a single *Blog Post*.
     * Get a Blog Post
     */
    async getABlogPost(requestParameters: GetABlogPostRequest, initOverrides?: RequestInit): Promise<BlogPostFull> {
        const response = await this.getABlogPostRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns a count of all *Blog Posts*.
     * Get A Count of All Blog Posts
     */
    async getACountOfAllBlogPostsRaw(requestParameters: GetACountOfAllBlogPostsRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<CountResponse>> {
        if (requestParameters.accept === null || requestParameters.accept === undefined) {
            throw new runtime.RequiredError('accept','Required parameter requestParameters.accept was null or undefined when calling getACountOfAllBlogPosts.');
        }

        if (requestParameters.contentType === null || requestParameters.contentType === undefined) {
            throw new runtime.RequiredError('contentType','Required parameter requestParameters.contentType was null or undefined when calling getACountOfAllBlogPosts.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
            headerParameters['Accept'] = String(requestParameters.accept);
        }

        if (requestParameters.contentType !== undefined && requestParameters.contentType !== null) {
            headerParameters['Content-Type'] = String(requestParameters.contentType);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-Auth-Token"] = this.configuration.apiKey("X-Auth-Token"); // X-Auth-Token authentication
        }

        const response = await this.request({
            path: `/blog/posts/count`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CountResponseFromJSON(jsonValue));
    }

    /**
     * Returns a count of all *Blog Posts*.
     * Get A Count of All Blog Posts
     */
    async getACountOfAllBlogPosts(requestParameters: GetACountOfAllBlogPostsRequest, initOverrides?: RequestInit): Promise<CountResponse> {
        const response = await this.getACountOfAllBlogPostsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns all *Blog Posts*. Default sorting is by published_date, beginning with the most recent post.
     * Get All Blog Posts
     */
    async getAllBlogPostsRaw(requestParameters: GetAllBlogPostsRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<Array<BlogPostFull>>> {
        if (requestParameters.accept === null || requestParameters.accept === undefined) {
            throw new runtime.RequiredError('accept','Required parameter requestParameters.accept was null or undefined when calling getAllBlogPosts.');
        }

        if (requestParameters.contentType === null || requestParameters.contentType === undefined) {
            throw new runtime.RequiredError('contentType','Required parameter requestParameters.contentType was null or undefined when calling getAllBlogPosts.');
        }

        const queryParameters: any = {};

        if (requestParameters.isPublished !== undefined) {
            queryParameters['is_published'] = requestParameters.isPublished;
        }

        if (requestParameters.url !== undefined) {
            queryParameters['url'] = requestParameters.url;
        }

        if (requestParameters.tag !== undefined) {
            queryParameters['tag'] = requestParameters.tag;
        }

        if (requestParameters.publishedDate !== undefined) {
            queryParameters['published_date'] = (requestParameters.publishedDate as any).toISOString();
        }

        if (requestParameters.page !== undefined) {
            queryParameters['page'] = requestParameters.page;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
            headerParameters['Accept'] = String(requestParameters.accept);
        }

        if (requestParameters.contentType !== undefined && requestParameters.contentType !== null) {
            headerParameters['Content-Type'] = String(requestParameters.contentType);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-Auth-Token"] = this.configuration.apiKey("X-Auth-Token"); // X-Auth-Token authentication
        }

        const response = await this.request({
            path: `/blog/posts`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(BlogPostFullFromJSON));
    }

    /**
     * Returns all *Blog Posts*. Default sorting is by published_date, beginning with the most recent post.
     * Get All Blog Posts
     */
    async getAllBlogPosts(requestParameters: GetAllBlogPostsRequest, initOverrides?: RequestInit): Promise<Array<BlogPostFull>> {
        const response = await this.getAllBlogPostsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Updates a *Blog Post*.  **Read Only Fields** *   id *   preview_url  **Notes**  * When including `published_date` in a request, supply it as a flat date string (not an object) in valid <a href=\"http://tools.ietf.org/html/rfc2822#section-3.3\" target=\"_blank\">RFC 2822</a>. The&#160;example request below includes a `published_date` in RFC 2822 format. 
     * Update a Blog Post
     */
    async updateABlogPostRaw(requestParameters: UpdateABlogPostRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<BlogPostBase>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling updateABlogPost.');
        }

        if (requestParameters.accept === null || requestParameters.accept === undefined) {
            throw new runtime.RequiredError('accept','Required parameter requestParameters.accept was null or undefined when calling updateABlogPost.');
        }

        if (requestParameters.contentType === null || requestParameters.contentType === undefined) {
            throw new runtime.RequiredError('contentType','Required parameter requestParameters.contentType was null or undefined when calling updateABlogPost.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling updateABlogPost.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
            headerParameters['Accept'] = String(requestParameters.accept);
        }

        if (requestParameters.contentType !== undefined && requestParameters.contentType !== null) {
            headerParameters['Content-Type'] = String(requestParameters.contentType);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-Auth-Token"] = this.configuration.apiKey("X-Auth-Token"); // X-Auth-Token authentication
        }

        const response = await this.request({
            path: `/blog/posts/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: BlogPostBaseToJSON(requestParameters.body),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => BlogPostBaseFromJSON(jsonValue));
    }

    /**
     * Updates a *Blog Post*.  **Read Only Fields** *   id *   preview_url  **Notes**  * When including `published_date` in a request, supply it as a flat date string (not an object) in valid <a href=\"http://tools.ietf.org/html/rfc2822#section-3.3\" target=\"_blank\">RFC 2822</a>. The&#160;example request below includes a `published_date` in RFC 2822 format. 
     * Update a Blog Post
     */
    async updateABlogPost(requestParameters: UpdateABlogPostRequest, initOverrides?: RequestInit): Promise<BlogPostBase> {
        const response = await this.updateABlogPostRaw(requestParameters, initOverrides);
        return await response.value();
    }

}
