/* tslint:disable */
/* eslint-disable */
/**
 * Orders V2
 * Manage order coupons, messages, products, shipping addresses, statuses, taxes, shipments, and shipping address quotes.  - [Authentication](#authentication) - [Order](#order)  ## Authentication  Authenticate requests by including an [OAuth](https://developer.bigcommerce.com/api-docs/getting-started/authentication) `access_token` request header.  ```http GET https://api.bigcommerce.com/stores/{{STORE_HASH}}/v3/{{ENDPOINT}} Content-Type: application/json X-Auth-Token: {{ACCESS_TOKEN}} ```  ### OAuth Scopes  |  **UI Name** | **Permission** | **Parameter** | | --- | --- | --- | |  Orders | modify | `store_v2_orders` | |  Orders | read-only | `store_v2_orders_read_only` |   ## Order  The Order object contains a record of the purchase agreement between a shopper and a merchant. To learn more about creating orders, see [Orders API Guide](/api-docs/orders/orders-api-overview).  ### Currency Fields  The **default** currency refers to the transactional currency which is the currency the shopper pays in.  The **display** currency refers to the presentational currency used to present prices to the shopper on the storefront.  * `currency_id` - the display currency ID. Depending on the currency selected, the value may be different from the transactional currency. * `currency_code` - the currency code of the display currency used to present prices to the shopper on the storefront. Depending on the currency selected, the value may be different from the transactional currency. * `currency_exchange_rate` - the exchange rate between the store\'s default currency and the display currency. For orders created using the V2 endpoints, this value is always 1 (only in the storefront this value can be different to 1). * `default_currency_id` - the transactional currency ID. * `default_currency_code` - the currency code of the transactional currency the shopper pays in.  The following additional fields are returned on orders when Multi-Currency is enabled on the store:  * `store_default_currency_code` - the currency code of the store\'s default currency. * `store_default_to_transactional_exchange_rate` - the exchange rate between the store\'s default currency and the transactional currency used in the order.  **Example:**  ```json {   ...   \"currency_id\": 4,   \"currency_code\": \"EUR\",   \"currency_exchange_rate\": 1,   \"default_currency_id\": 4,   \"default_currency_code\": \"EUR\",   \"store_default_currency_code\": \"USD\",   \"store_default_to_transactional_exchange_rate\": \"100.0000000000\"   ... } ```
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import {
    OrderPost,
    OrderPostFromJSON,
    OrderPostToJSON,
    OrderPut,
    OrderPutFromJSON,
    OrderPutToJSON,
    OrderResp,
    OrderRespFromJSON,
    OrderRespToJSON,
    OrdersCountFull,
    OrdersCountFullFromJSON,
    OrdersCountFullToJSON,
} from '../models';

export interface CreateAnOrderRequest {
    accept: string;
    contentType: string;
    orderPost: OrderPost;
}

export interface DeleteAllOrdersRequest {
    accept: string;
    contentType: string;
}

export interface DeleteAnOrderRequest {
    orderId: number;
    accept: string;
    contentType: string;
}

export interface GetAllOrdersRequest {
    accept: string;
    contentType: string;
    minId?: number;
    maxId?: number;
    minTotal?: number;
    maxTotal?: number;
    customerId?: number;
    email?: string;
    statusId?: number;
    cartId?: string;
    paymentMethod?: GetAllOrdersPaymentMethodEnum;
    minDateCreated?: string;
    maxDateCreated?: string;
    minDateModified?: string;
    maxDateModified?: string;
    page?: number;
    limit?: number;
    sort?: GetAllOrdersSortEnum;
    isDeleted?: boolean;
    channelId?: number;
}

export interface GetAnOrderRequest {
    orderId: number;
    accept: string;
    contentType: string;
}

export interface GetCountOrderRequest {
    accept: string;
    contentType: string;
}

export interface UpdateAnOrderRequest {
    orderId: number;
    accept: string;
    contentType: string;
    orderPut: OrderPut;
}

/**
 * 
 */
export class OrdersApi extends runtime.BaseAPI {

    /**
     * Creates an *Order*. To learn more about creating or updating orders, see [Orders Overview](/api-docs/orders/orders-api-overview).  An order can be created with an existing catalog product or a custom product.  **Required Fields**  *   products *   billing_address
     * Create an Order
     */
    async createAnOrderRaw(requestParameters: CreateAnOrderRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<OrderResp>> {
        if (requestParameters.accept === null || requestParameters.accept === undefined) {
            throw new runtime.RequiredError('accept','Required parameter requestParameters.accept was null or undefined when calling createAnOrder.');
        }

        if (requestParameters.contentType === null || requestParameters.contentType === undefined) {
            throw new runtime.RequiredError('contentType','Required parameter requestParameters.contentType was null or undefined when calling createAnOrder.');
        }

        if (requestParameters.orderPost === null || requestParameters.orderPost === undefined) {
            throw new runtime.RequiredError('orderPost','Required parameter requestParameters.orderPost was null or undefined when calling createAnOrder.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
            headerParameters['Accept'] = String(requestParameters.accept);
        }

        if (requestParameters.contentType !== undefined && requestParameters.contentType !== null) {
            headerParameters['Content-Type'] = String(requestParameters.contentType);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-Auth-Token"] = this.configuration.apiKey("X-Auth-Token"); // X-Auth-Token authentication
        }

        const response = await this.request({
            path: `/orders`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: OrderPostToJSON(requestParameters.orderPost),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => OrderRespFromJSON(jsonValue));
    }

    /**
     * Creates an *Order*. To learn more about creating or updating orders, see [Orders Overview](/api-docs/orders/orders-api-overview).  An order can be created with an existing catalog product or a custom product.  **Required Fields**  *   products *   billing_address
     * Create an Order
     */
    async createAnOrder(requestParameters: CreateAnOrderRequest, initOverrides?: RequestInit): Promise<OrderResp> {
        const response = await this.createAnOrderRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Archives all orders.
     * Delete All Orders
     */
    async deleteAllOrdersRaw(requestParameters: DeleteAllOrdersRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.accept === null || requestParameters.accept === undefined) {
            throw new runtime.RequiredError('accept','Required parameter requestParameters.accept was null or undefined when calling deleteAllOrders.');
        }

        if (requestParameters.contentType === null || requestParameters.contentType === undefined) {
            throw new runtime.RequiredError('contentType','Required parameter requestParameters.contentType was null or undefined when calling deleteAllOrders.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
            headerParameters['Accept'] = String(requestParameters.accept);
        }

        if (requestParameters.contentType !== undefined && requestParameters.contentType !== null) {
            headerParameters['Content-Type'] = String(requestParameters.contentType);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-Auth-Token"] = this.configuration.apiKey("X-Auth-Token"); // X-Auth-Token authentication
        }

        const response = await this.request({
            path: `/orders`,
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Archives all orders.
     * Delete All Orders
     */
    async deleteAllOrders(requestParameters: DeleteAllOrdersRequest, initOverrides?: RequestInit): Promise<void> {
        await this.deleteAllOrdersRaw(requestParameters, initOverrides);
    }

    /**
     * Archives an order.
     * Archive an Order
     */
    async deleteAnOrderRaw(requestParameters: DeleteAnOrderRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.orderId === null || requestParameters.orderId === undefined) {
            throw new runtime.RequiredError('orderId','Required parameter requestParameters.orderId was null or undefined when calling deleteAnOrder.');
        }

        if (requestParameters.accept === null || requestParameters.accept === undefined) {
            throw new runtime.RequiredError('accept','Required parameter requestParameters.accept was null or undefined when calling deleteAnOrder.');
        }

        if (requestParameters.contentType === null || requestParameters.contentType === undefined) {
            throw new runtime.RequiredError('contentType','Required parameter requestParameters.contentType was null or undefined when calling deleteAnOrder.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
            headerParameters['Accept'] = String(requestParameters.accept);
        }

        if (requestParameters.contentType !== undefined && requestParameters.contentType !== null) {
            headerParameters['Content-Type'] = String(requestParameters.contentType);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-Auth-Token"] = this.configuration.apiKey("X-Auth-Token"); // X-Auth-Token authentication
        }

        const response = await this.request({
            path: `/orders/{order_id}`.replace(`{${"order_id"}}`, encodeURIComponent(String(requestParameters.orderId))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Archives an order.
     * Archive an Order
     */
    async deleteAnOrder(requestParameters: DeleteAnOrderRequest, initOverrides?: RequestInit): Promise<void> {
        await this.deleteAnOrderRaw(requestParameters, initOverrides);
    }

    /**
     * Gets a list of orders using the filter query.  **Notes**  The default sort is by order id, from lowest to highest.
     * Get All Orders
     */
    async getAllOrdersRaw(requestParameters: GetAllOrdersRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<Array<OrderResp>>> {
        if (requestParameters.accept === null || requestParameters.accept === undefined) {
            throw new runtime.RequiredError('accept','Required parameter requestParameters.accept was null or undefined when calling getAllOrders.');
        }

        if (requestParameters.contentType === null || requestParameters.contentType === undefined) {
            throw new runtime.RequiredError('contentType','Required parameter requestParameters.contentType was null or undefined when calling getAllOrders.');
        }

        const queryParameters: any = {};

        if (requestParameters.minId !== undefined) {
            queryParameters['min_id'] = requestParameters.minId;
        }

        if (requestParameters.maxId !== undefined) {
            queryParameters['max_id'] = requestParameters.maxId;
        }

        if (requestParameters.minTotal !== undefined) {
            queryParameters['min_total'] = requestParameters.minTotal;
        }

        if (requestParameters.maxTotal !== undefined) {
            queryParameters['max_total'] = requestParameters.maxTotal;
        }

        if (requestParameters.customerId !== undefined) {
            queryParameters['customer_id'] = requestParameters.customerId;
        }

        if (requestParameters.email !== undefined) {
            queryParameters['email'] = requestParameters.email;
        }

        if (requestParameters.statusId !== undefined) {
            queryParameters['status_id'] = requestParameters.statusId;
        }

        if (requestParameters.cartId !== undefined) {
            queryParameters['cart_id'] = requestParameters.cartId;
        }

        if (requestParameters.paymentMethod !== undefined) {
            queryParameters['payment_method'] = requestParameters.paymentMethod;
        }

        if (requestParameters.minDateCreated !== undefined) {
            queryParameters['min_date_created'] = requestParameters.minDateCreated;
        }

        if (requestParameters.maxDateCreated !== undefined) {
            queryParameters['max_date_created'] = requestParameters.maxDateCreated;
        }

        if (requestParameters.minDateModified !== undefined) {
            queryParameters['min_date_modified'] = requestParameters.minDateModified;
        }

        if (requestParameters.maxDateModified !== undefined) {
            queryParameters['max_date_modified'] = requestParameters.maxDateModified;
        }

        if (requestParameters.page !== undefined) {
            queryParameters['page'] = requestParameters.page;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.sort !== undefined) {
            queryParameters['sort'] = requestParameters.sort;
        }

        if (requestParameters.isDeleted !== undefined) {
            queryParameters['is_deleted'] = requestParameters.isDeleted;
        }

        if (requestParameters.channelId !== undefined) {
            queryParameters['channel_id'] = requestParameters.channelId;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
            headerParameters['Accept'] = String(requestParameters.accept);
        }

        if (requestParameters.contentType !== undefined && requestParameters.contentType !== null) {
            headerParameters['Content-Type'] = String(requestParameters.contentType);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-Auth-Token"] = this.configuration.apiKey("X-Auth-Token"); // X-Auth-Token authentication
        }

        const response = await this.request({
            path: `/orders`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(OrderRespFromJSON));
    }

    /**
     * Gets a list of orders using the filter query.  **Notes**  The default sort is by order id, from lowest to highest.
     * Get All Orders
     */
    async getAllOrders(requestParameters: GetAllOrdersRequest, initOverrides?: RequestInit): Promise<Array<OrderResp>> {
        const response = await this.getAllOrdersRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Gets an *Order*. To learn more about creating or updating orders, see [Orders Overview](/api-docs/orders/orders-api-overview).
     * Get an Order
     */
    async getAnOrderRaw(requestParameters: GetAnOrderRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<OrderResp>> {
        if (requestParameters.orderId === null || requestParameters.orderId === undefined) {
            throw new runtime.RequiredError('orderId','Required parameter requestParameters.orderId was null or undefined when calling getAnOrder.');
        }

        if (requestParameters.accept === null || requestParameters.accept === undefined) {
            throw new runtime.RequiredError('accept','Required parameter requestParameters.accept was null or undefined when calling getAnOrder.');
        }

        if (requestParameters.contentType === null || requestParameters.contentType === undefined) {
            throw new runtime.RequiredError('contentType','Required parameter requestParameters.contentType was null or undefined when calling getAnOrder.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
            headerParameters['Accept'] = String(requestParameters.accept);
        }

        if (requestParameters.contentType !== undefined && requestParameters.contentType !== null) {
            headerParameters['Content-Type'] = String(requestParameters.contentType);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-Auth-Token"] = this.configuration.apiKey("X-Auth-Token"); // X-Auth-Token authentication
        }

        const response = await this.request({
            path: `/orders/{order_id}`.replace(`{${"order_id"}}`, encodeURIComponent(String(requestParameters.orderId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => OrderRespFromJSON(jsonValue));
    }

    /**
     * Gets an *Order*. To learn more about creating or updating orders, see [Orders Overview](/api-docs/orders/orders-api-overview).
     * Get an Order
     */
    async getAnOrder(requestParameters: GetAnOrderRequest, initOverrides?: RequestInit): Promise<OrderResp> {
        const response = await this.getAnOrderRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Gets an array of orders in the store organized by order status.
     * Get a Count of Orders
     */
    async getCountOrderRaw(requestParameters: GetCountOrderRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<OrdersCountFull>> {
        if (requestParameters.accept === null || requestParameters.accept === undefined) {
            throw new runtime.RequiredError('accept','Required parameter requestParameters.accept was null or undefined when calling getCountOrder.');
        }

        if (requestParameters.contentType === null || requestParameters.contentType === undefined) {
            throw new runtime.RequiredError('contentType','Required parameter requestParameters.contentType was null or undefined when calling getCountOrder.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
            headerParameters['Accept'] = String(requestParameters.accept);
        }

        if (requestParameters.contentType !== undefined && requestParameters.contentType !== null) {
            headerParameters['Content-Type'] = String(requestParameters.contentType);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-Auth-Token"] = this.configuration.apiKey("X-Auth-Token"); // X-Auth-Token authentication
        }

        const response = await this.request({
            path: `/orders/count`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => OrdersCountFullFromJSON(jsonValue));
    }

    /**
     * Gets an array of orders in the store organized by order status.
     * Get a Count of Orders
     */
    async getCountOrder(requestParameters: GetCountOrderRequest, initOverrides?: RequestInit): Promise<OrdersCountFull> {
        const response = await this.getCountOrderRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Updates an *Order*. To learn more about creating or updating orders, see [Orders Overview](/api-docs/orders/orders-api-overview).
     * Update an Order
     */
    async updateAnOrderRaw(requestParameters: UpdateAnOrderRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<OrderResp>> {
        if (requestParameters.orderId === null || requestParameters.orderId === undefined) {
            throw new runtime.RequiredError('orderId','Required parameter requestParameters.orderId was null or undefined when calling updateAnOrder.');
        }

        if (requestParameters.accept === null || requestParameters.accept === undefined) {
            throw new runtime.RequiredError('accept','Required parameter requestParameters.accept was null or undefined when calling updateAnOrder.');
        }

        if (requestParameters.contentType === null || requestParameters.contentType === undefined) {
            throw new runtime.RequiredError('contentType','Required parameter requestParameters.contentType was null or undefined when calling updateAnOrder.');
        }

        if (requestParameters.orderPut === null || requestParameters.orderPut === undefined) {
            throw new runtime.RequiredError('orderPut','Required parameter requestParameters.orderPut was null or undefined when calling updateAnOrder.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
            headerParameters['Accept'] = String(requestParameters.accept);
        }

        if (requestParameters.contentType !== undefined && requestParameters.contentType !== null) {
            headerParameters['Content-Type'] = String(requestParameters.contentType);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-Auth-Token"] = this.configuration.apiKey("X-Auth-Token"); // X-Auth-Token authentication
        }

        const response = await this.request({
            path: `/orders/{order_id}`.replace(`{${"order_id"}}`, encodeURIComponent(String(requestParameters.orderId))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: OrderPutToJSON(requestParameters.orderPut),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => OrderRespFromJSON(jsonValue));
    }

    /**
     * Updates an *Order*. To learn more about creating or updating orders, see [Orders Overview](/api-docs/orders/orders-api-overview).
     * Update an Order
     */
    async updateAnOrder(requestParameters: UpdateAnOrderRequest, initOverrides?: RequestInit): Promise<OrderResp> {
        const response = await this.updateAnOrderRaw(requestParameters, initOverrides);
        return await response.value();
    }

}

/**
    * @export
    * @enum {string}
    */
export enum GetAllOrdersPaymentMethodEnum {
    Manual = 'Manual',
    CashOnDelivery = 'Cash on Delivery',
    CreditCard = 'Credit Card',
    TestPaymentGateway = 'Test Payment Gateway',
    PayInStore = 'Pay In Store'
}
/**
    * @export
    * @enum {string}
    */
export enum GetAllOrdersSortEnum {
    Id = 'id',
    CustomerId = 'customer_id',
    DateCreated = 'date_created',
    DateModified = 'date_modified',
    StatusId = 'status_id',
    ChannelId = 'channel_id',
    ExternalId = 'external_id'
}
