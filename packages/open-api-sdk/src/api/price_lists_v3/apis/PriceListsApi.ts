/* tslint:disable */
/* eslint-disable */
/**
 * Price Lists
 * Populate different versions of catalog pricing and assign them to different [customer groups](/api-reference/customer-subscribers/customers-api) at the variant level.  - [Authentication](#authentication) - [Price Lists](#price-lists) - [Price Lists Assignments](#price-lists-assignments) - [Usage notes](#usage-notes) - [Additional information](#additional-information)  ## Authentication  Authenticate requests by including an [OAuth](https://developer.bigcommerce.com/api-docs/getting-started/authentication) `access_token` in the request headers.  ```http GET https://api.bigcommerce.com/stores/{{STORE_HASH}}/v3/{{ENDPOINT}} Content-Type: application/json X-Auth-Token: {{ACCESS_TOKEN}} ```  ### OAuth Scopes  | UI Name                                      | Permission | Parameter                                     | |----------------------------------------------|------------|-----------------------------------------------| | Products                                     | modify     | `store_v2_products`                           | | Products                                     | read-only  | `store_v2_products_read_only`                 |  ## Price Lists  The association of a Price List to a customer group can be done either via the control panel or using the [Customer Groups API.](/api-reference/customer-subscribers/customers-api)  [Price List Assignments](https://developer.bigcommerce.com/api-reference/store-management/price-lists/price-lists-records/) can be created to assign Price Lists to a specific [channel](https://developer.bigcommerce.com/api-reference/cart-checkout/channels-listings-api). Price Lists assigned to a channel apply to all shoppers on that channel, unless there are more specific assignments or customer group discounts set up for the shopper\'s customer group.  If an active Price List does not contain prices for a variant, then the catalog pricing will be used.  Price Lists provide overridden price values to the Stencil storefront. Final price display can be further customized within the Stencil template using the template\'s [price](https://developer.bigcommerce.com/stencil-docs/reference-docs/global-objects-and-properties/models/price) object.  To learn more about Price Lists, see [Price Lists API](/api-docs/store-management/price-list-overview).  ## Price Lists Assignments  ### Order of operations  **IF** Price List assigned to current customer group **AND** Price List assigned to current channel: * Use this Price List -- any prices not found fall back to the catalog price (or in the case of multi-currency, auto-converted prices)  **ELSE IF** Price List assigned to current customer group: * Use this Price List -- any prices not found fall back to the catalog price (or in the case of multi-currency, auto-converted prices)  **ELSE IF** Customer group discounts: * Use them -- any prices not found fall back to the catalog price (or in the case of multi-currency, auto-converted prices)  **ELSE IF** Channel has a default Price List: * Use this Price List -- any prices not found fall back to the catalog price (or in the case of multi-currency, auto-converted prices)  **ELSE**: * Fall back to the catalog price (or in the case of multi-currency, auto-converted prices)  ## Usage notes - Price Lists cannot be assigned to a customer group that has customer group discounts -- the customer group discounts must be deleted first. - Bulk pricing Tiers may additionally be associated with a price record to indicate different pricing as the quantity in the cart increases. - If a variant has a Price Record, any existing product-level bulk pricing will not apply in the cart. For variants without Price Records, any existing product bulk pricing will apply. - [Price Lists Records](https://developer.bigcommerce.com/api-reference/store-management/price-lists/price-lists-records/setpricelistrecordcollection) accepts bulk upsert. You can only do one bulk upsert at a time. Running more than one in parallel on the **same store** will cause a 429 error and the request will fail. - There are no webhooks available for Price Lists. Since Price Lists directly relate to products, product webhooks will fire for corresponding changes such as pricing.  ## Additional information  ### Webhooks  * [Products](/api-docs/store-management/webhooks/events#products) * [SKU](/api-docs/store-management/webhooks/events#sku)  ### Related endpoints * [Get All Price Lists](/api-reference/store-management/price-lists/price-lists/getpricelistcollection)
 *
 * The version of the OpenAPI document: 
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import {
    ErrorResponse,
    ErrorResponseFromJSON,
    ErrorResponseToJSON,
    NotFound,
    NotFoundFromJSON,
    NotFoundToJSON,
    PriceListCollectionResponse,
    PriceListCollectionResponseFromJSON,
    PriceListCollectionResponseToJSON,
    PriceListResponse,
    PriceListResponseFromJSON,
    PriceListResponseToJSON,
    PriceListResponse1,
    PriceListResponse1FromJSON,
    PriceListResponse1ToJSON,
    UNKNOWN_BASE_TYPE,
    UNKNOWN_BASE_TYPEFromJSON,
    UNKNOWN_BASE_TYPEToJSON,
} from '../models';

export interface CreatePriceListRequest {
    priceList: UNKNOWN_BASE_TYPE;
    accept?: string;
    contentType?: string;
}

export interface DeletePriceListRequest {
    priceListId: number;
}

export interface DeletePriceListsByFilterRequest {
    id?: number;
    name?: string;
    accept?: string;
    contentType?: string;
}

export interface GetPriceListRequest {
    priceListId: number;
    id?: number;
    name?: string;
    dateCreated?: Date;
    dateModified?: Date;
    page?: number;
    limit?: number;
}

export interface GetPriceListCollectionRequest {
    id?: number;
    name?: string;
    dateCreated?: Date;
    dateModified?: Date;
    page?: number;
    limit?: number;
    contentType?: string;
    accept?: string;
    idin?: Array<string>;
    namelike?: Array<string>;
    dateCreatedmax?: string;
    dateCreatedmin?: string;
    dateModifiedmax?: string;
    dateModifiedmin?: string;
}

export interface UpdatePriceListRequest {
    priceListId: number;
    priceList: UNKNOWN_BASE_TYPE;
}

/**
 * 
 */
export class PriceListsApi extends runtime.BaseAPI {

    /**
     * Creates a *Price List*.  **Required Fields** * name
     * Create a Price List
     */
    async createPriceListRaw(requestParameters: CreatePriceListRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<PriceListResponse>> {
        if (requestParameters.priceList === null || requestParameters.priceList === undefined) {
            throw new runtime.RequiredError('priceList','Required parameter requestParameters.priceList was null or undefined when calling createPriceList.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
            headerParameters['Accept'] = String(requestParameters.accept);
        }

        if (requestParameters.contentType !== undefined && requestParameters.contentType !== null) {
            headerParameters['Content-Type'] = String(requestParameters.contentType);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-Auth-Token"] = this.configuration.apiKey("X-Auth-Token"); // X-Auth-Token authentication
        }

        const response = await this.request({
            path: `/pricelists`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: UNKNOWN_BASE_TYPEToJSON(requestParameters.priceList),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PriceListResponseFromJSON(jsonValue));
    }

    /**
     * Creates a *Price List*.  **Required Fields** * name
     * Create a Price List
     */
    async createPriceList(requestParameters: CreatePriceListRequest, initOverrides?: RequestInit): Promise<PriceListResponse> {
        const response = await this.createPriceListRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Deletes a *Price List*. All associated price records are also removed.  **Limits** * Limit of 1 concurrent request.
     * Delete a Price List
     */
    async deletePriceListRaw(requestParameters: DeletePriceListRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<object>> {
        if (requestParameters.priceListId === null || requestParameters.priceListId === undefined) {
            throw new runtime.RequiredError('priceListId','Required parameter requestParameters.priceListId was null or undefined when calling deletePriceList.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-Auth-Token"] = this.configuration.apiKey("X-Auth-Token"); // X-Auth-Token authentication
        }

        const response = await this.request({
            path: `/pricelists/{price_list_id}`.replace(`{${"price_list_id"}}`, encodeURIComponent(String(requestParameters.priceListId))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     * Deletes a *Price List*. All associated price records are also removed.  **Limits** * Limit of 1 concurrent request.
     * Delete a Price List
     */
    async deletePriceList(requestParameters: DeletePriceListRequest, initOverrides?: RequestInit): Promise<object> {
        const response = await this.deletePriceListRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Deletes a *Price List*. All associated price records are also removed. Optional parameters can be passed in.
     * Delete All Price Lists
     */
    async deletePriceListsByFilterRaw(requestParameters: DeletePriceListsByFilterRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<object>> {
        const queryParameters: any = {};

        if (requestParameters.id !== undefined) {
            queryParameters['id'] = requestParameters.id;
        }

        if (requestParameters.name !== undefined) {
            queryParameters['name'] = requestParameters.name;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
            headerParameters['Accept'] = String(requestParameters.accept);
        }

        if (requestParameters.contentType !== undefined && requestParameters.contentType !== null) {
            headerParameters['Content-Type'] = String(requestParameters.contentType);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-Auth-Token"] = this.configuration.apiKey("X-Auth-Token"); // X-Auth-Token authentication
        }

        const response = await this.request({
            path: `/pricelists`,
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     * Deletes a *Price List*. All associated price records are also removed. Optional parameters can be passed in.
     * Delete All Price Lists
     */
    async deletePriceListsByFilter(requestParameters: DeletePriceListsByFilterRequest, initOverrides?: RequestInit): Promise<object> {
        const response = await this.deletePriceListsByFilterRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     *  Returns a single *Price List*.
     * Get a Price List
     */
    async getPriceListRaw(requestParameters: GetPriceListRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<PriceListResponse1>> {
        if (requestParameters.priceListId === null || requestParameters.priceListId === undefined) {
            throw new runtime.RequiredError('priceListId','Required parameter requestParameters.priceListId was null or undefined when calling getPriceList.');
        }

        const queryParameters: any = {};

        if (requestParameters.id !== undefined) {
            queryParameters['id'] = requestParameters.id;
        }

        if (requestParameters.name !== undefined) {
            queryParameters['name'] = requestParameters.name;
        }

        if (requestParameters.dateCreated !== undefined) {
            queryParameters['date_created'] = (requestParameters.dateCreated as any).toISOString();
        }

        if (requestParameters.dateModified !== undefined) {
            queryParameters['date_modified'] = (requestParameters.dateModified as any).toISOString();
        }

        if (requestParameters.page !== undefined) {
            queryParameters['page'] = requestParameters.page;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-Auth-Token"] = this.configuration.apiKey("X-Auth-Token"); // X-Auth-Token authentication
        }

        const response = await this.request({
            path: `/pricelists/{price_list_id}`.replace(`{${"price_list_id"}}`, encodeURIComponent(String(requestParameters.priceListId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PriceListResponse1FromJSON(jsonValue));
    }

    /**
     *  Returns a single *Price List*.
     * Get a Price List
     */
    async getPriceList(requestParameters: GetPriceListRequest, initOverrides?: RequestInit): Promise<PriceListResponse1> {
        const response = await this.getPriceListRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns a list of *Price Lists*. Optional parameters can be passed in.
     * Get All Price Lists
     */
    async getPriceListCollectionRaw(requestParameters: GetPriceListCollectionRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<PriceListCollectionResponse>> {
        const queryParameters: any = {};

        if (requestParameters.id !== undefined) {
            queryParameters['id'] = requestParameters.id;
        }

        if (requestParameters.name !== undefined) {
            queryParameters['name'] = requestParameters.name;
        }

        if (requestParameters.dateCreated !== undefined) {
            queryParameters['date_created'] = (requestParameters.dateCreated as any).toISOString();
        }

        if (requestParameters.dateModified !== undefined) {
            queryParameters['date_modified'] = (requestParameters.dateModified as any).toISOString();
        }

        if (requestParameters.page !== undefined) {
            queryParameters['page'] = requestParameters.page;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.idin) {
            queryParameters['id:in'] = requestParameters.idin.join(runtime.COLLECTION_FORMATS["csv"]);
        }

        if (requestParameters.namelike) {
            queryParameters['name:like'] = requestParameters.namelike.join(runtime.COLLECTION_FORMATS["csv"]);
        }

        if (requestParameters.dateCreatedmax !== undefined) {
            queryParameters['date_created:max'] = requestParameters.dateCreatedmax;
        }

        if (requestParameters.dateCreatedmin !== undefined) {
            queryParameters['date_created:min'] = requestParameters.dateCreatedmin;
        }

        if (requestParameters.dateModifiedmax !== undefined) {
            queryParameters['date_modified:max'] = requestParameters.dateModifiedmax;
        }

        if (requestParameters.dateModifiedmin !== undefined) {
            queryParameters['date_modified:min'] = requestParameters.dateModifiedmin;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.contentType !== undefined && requestParameters.contentType !== null) {
            headerParameters['Content-Type'] = String(requestParameters.contentType);
        }

        if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
            headerParameters['Accept'] = String(requestParameters.accept);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-Auth-Token"] = this.configuration.apiKey("X-Auth-Token"); // X-Auth-Token authentication
        }

        const response = await this.request({
            path: `/pricelists`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PriceListCollectionResponseFromJSON(jsonValue));
    }

    /**
     * Returns a list of *Price Lists*. Optional parameters can be passed in.
     * Get All Price Lists
     */
    async getPriceListCollection(requestParameters: GetPriceListCollectionRequest, initOverrides?: RequestInit): Promise<PriceListCollectionResponse> {
        const response = await this.getPriceListCollectionRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Updates a *Price List*.
     * Update a Price List
     */
    async updatePriceListRaw(requestParameters: UpdatePriceListRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<PriceListResponse>> {
        if (requestParameters.priceListId === null || requestParameters.priceListId === undefined) {
            throw new runtime.RequiredError('priceListId','Required parameter requestParameters.priceListId was null or undefined when calling updatePriceList.');
        }

        if (requestParameters.priceList === null || requestParameters.priceList === undefined) {
            throw new runtime.RequiredError('priceList','Required parameter requestParameters.priceList was null or undefined when calling updatePriceList.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-Auth-Token"] = this.configuration.apiKey("X-Auth-Token"); // X-Auth-Token authentication
        }

        const response = await this.request({
            path: `/pricelists/{price_list_id}`.replace(`{${"price_list_id"}}`, encodeURIComponent(String(requestParameters.priceListId))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: UNKNOWN_BASE_TYPEToJSON(requestParameters.priceList),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PriceListResponseFromJSON(jsonValue));
    }

    /**
     * Updates a *Price List*.
     * Update a Price List
     */
    async updatePriceList(requestParameters: UpdatePriceListRequest, initOverrides?: RequestInit): Promise<PriceListResponse> {
        const response = await this.updatePriceListRaw(requestParameters, initOverrides);
        return await response.value();
    }

}
