/* tslint:disable */
/* eslint-disable */
/**
 * Price Lists
 * Populate different versions of catalog pricing and assign them to different [customer groups](/api-reference/customer-subscribers/customers-api) at the variant level.  - [Authentication](#authentication) - [Price Lists](#price-lists) - [Price Lists Assignments](#price-lists-assignments) - [Usage notes](#usage-notes) - [Additional information](#additional-information)  ## Authentication  Authenticate requests by including an [OAuth](https://developer.bigcommerce.com/api-docs/getting-started/authentication) `access_token` in the request headers.  ```http GET https://api.bigcommerce.com/stores/{{STORE_HASH}}/v3/{{ENDPOINT}} Content-Type: application/json X-Auth-Token: {{ACCESS_TOKEN}} ```  ### OAuth Scopes  | UI Name                                      | Permission | Parameter                                     | |----------------------------------------------|------------|-----------------------------------------------| | Products                                     | modify     | `store_v2_products`                           | | Products                                     | read-only  | `store_v2_products_read_only`                 |  ## Price Lists  The association of a Price List to a customer group can be done either via the control panel or using the [Customer Groups API.](/api-reference/customer-subscribers/customers-api)  [Price List Assignments](https://developer.bigcommerce.com/api-reference/store-management/price-lists/price-lists-records/) can be created to assign Price Lists to a specific [channel](https://developer.bigcommerce.com/api-reference/cart-checkout/channels-listings-api). Price Lists assigned to a channel apply to all shoppers on that channel, unless there are more specific assignments or customer group discounts set up for the shopper\'s customer group.  If an active Price List does not contain prices for a variant, then the catalog pricing will be used.  Price Lists provide overridden price values to the Stencil storefront. Final price display can be further customized within the Stencil template using the template\'s [price](https://developer.bigcommerce.com/stencil-docs/reference-docs/global-objects-and-properties/models/price) object.  To learn more about Price Lists, see [Price Lists API](/api-docs/store-management/price-list-overview).  ## Price Lists Assignments  ### Order of operations  **IF** Price List assigned to current customer group **AND** Price List assigned to current channel: * Use this Price List -- any prices not found fall back to the catalog price (or in the case of multi-currency, auto-converted prices)  **ELSE IF** Price List assigned to current customer group: * Use this Price List -- any prices not found fall back to the catalog price (or in the case of multi-currency, auto-converted prices)  **ELSE IF** Customer group discounts: * Use them -- any prices not found fall back to the catalog price (or in the case of multi-currency, auto-converted prices)  **ELSE IF** Channel has a default Price List: * Use this Price List -- any prices not found fall back to the catalog price (or in the case of multi-currency, auto-converted prices)  **ELSE**: * Fall back to the catalog price (or in the case of multi-currency, auto-converted prices)  ## Usage notes - Price Lists cannot be assigned to a customer group that has customer group discounts -- the customer group discounts must be deleted first. - Bulk pricing Tiers may additionally be associated with a price record to indicate different pricing as the quantity in the cart increases. - If a variant has a Price Record, any existing product-level bulk pricing will not apply in the cart. For variants without Price Records, any existing product bulk pricing will apply. - [Price Lists Records](https://developer.bigcommerce.com/api-reference/store-management/price-lists/price-lists-records/setpricelistrecordcollection) accepts bulk upsert. You can only do one bulk upsert at a time. Running more than one in parallel on the **same store** will cause a 429 error and the request will fail. - There are no webhooks available for Price Lists. Since Price Lists directly relate to products, product webhooks will fire for corresponding changes such as pricing.  ## Additional information  ### Webhooks  * [Products](/api-docs/store-management/webhooks/events#products) * [SKU](/api-docs/store-management/webhooks/events#sku)  ### Related endpoints * [Get All Price Lists](/api-reference/store-management/price-lists/price-lists/getpricelistcollection)
 *
 * The version of the OpenAPI document: 
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import {
    ErrorResponse,
    ErrorResponseFromJSON,
    ErrorResponseToJSON,
    NoContent,
    NoContentFromJSON,
    NoContentToJSON,
    NotFound,
    NotFoundFromJSON,
    NotFoundToJSON,
    PriceRecordBatchErrorResponse,
    PriceRecordBatchErrorResponseFromJSON,
    PriceRecordBatchErrorResponseToJSON,
    PriceRecordCollectionResponse,
    PriceRecordCollectionResponseFromJSON,
    PriceRecordCollectionResponseToJSON,
    PriceRecordResponse,
    PriceRecordResponseFromJSON,
    PriceRecordResponseToJSON,
    UNKNOWN_BASE_TYPE,
    UNKNOWN_BASE_TYPEFromJSON,
    UNKNOWN_BASE_TYPEToJSON,
} from '../models';

export interface DeletePriceListRecordRequest {
    priceListId: number;
    variantId: number;
    currencyCode: string;
    contentType?: string;
    accept?: string;
}

export interface DeletePriceListRecordsByFilterRequest {
    priceListId: number;
    variantIdin?: number;
    accept?: string;
    contentType?: string;
}

export interface GetPriceListRecordRequest {
    priceListId: number;
    variantId: number;
    currencyCode: string;
    include?: GetPriceListRecordIncludeEnum;
    accept?: string;
    contentType?: string;
}

export interface GetPriceListRecordCollectionRequest {
    priceListId: number;
    variantIdin?: number;
    productIdin?: string;
    currency?: string;
    page?: number;
    limit?: number;
    include?: GetPriceListRecordCollectionIncludeEnum;
    price?: number;
    salePrice?: number;
    retailPrice?: number;
    mapPrice?: number;
    calculatedPrice?: number;
    dateCreated?: Date;
    dateModified?: Date;
    sku?: string;
    contentType?: string;
    accept?: string;
    skuin?: Array<string>;
    currencyin?: Array<string>;
    pricemax?: number;
    pricemin?: number;
    salePricemax?: number;
    salePricemin?: number;
    retailPricemax?: number;
    retailPricemin?: number;
    mapPricemax?: number;
    mapPricemin?: number;
    calculatedPricemax?: number;
    calculatedPricemin?: number;
    dateCreatedmax?: string;
    dateCreatedmin?: string;
    dateModifiedmax?: string;
    dateModifiedmin?: string;
}

export interface GetPriceListRecordsByVariantIdRequest {
    priceListId: number;
    variantId: number;
    accept?: string;
    contentType?: string;
}

export interface SetPriceListRecordRequest {
    priceListId: number;
    variantId: number;
    currencyCode: string;
    priceRecord: UNKNOWN_BASE_TYPE;
    accept?: string;
    contentType?: string;
}

export interface SetPriceListRecordCollectionRequest {
    priceListId: number;
    priceRecordBatch: Array<object>;
    xStrictMode?: number;
    accept?: string;
    contentType?: string;
}

/**
 * 
 */
export class PriceListsRecordsApi extends runtime.BaseAPI {

    /**
     * Deletes a *Price List Record* using the currency code. 
     * Delete a Price Record by Currency Code
     */
    async deletePriceListRecordRaw(requestParameters: DeletePriceListRecordRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.priceListId === null || requestParameters.priceListId === undefined) {
            throw new runtime.RequiredError('priceListId','Required parameter requestParameters.priceListId was null or undefined when calling deletePriceListRecord.');
        }

        if (requestParameters.variantId === null || requestParameters.variantId === undefined) {
            throw new runtime.RequiredError('variantId','Required parameter requestParameters.variantId was null or undefined when calling deletePriceListRecord.');
        }

        if (requestParameters.currencyCode === null || requestParameters.currencyCode === undefined) {
            throw new runtime.RequiredError('currencyCode','Required parameter requestParameters.currencyCode was null or undefined when calling deletePriceListRecord.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.contentType !== undefined && requestParameters.contentType !== null) {
            headerParameters['Content-Type'] = String(requestParameters.contentType);
        }

        if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
            headerParameters['Accept'] = String(requestParameters.accept);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-Auth-Token"] = this.configuration.apiKey("X-Auth-Token"); // X-Auth-Token authentication
        }

        const response = await this.request({
            path: `/pricelists/{price_list_id}/records/{variant_id}/{currency_code}`.replace(`{${"price_list_id"}}`, encodeURIComponent(String(requestParameters.priceListId))).replace(`{${"variant_id"}}`, encodeURIComponent(String(requestParameters.variantId))).replace(`{${"currency_code"}}`, encodeURIComponent(String(requestParameters.currencyCode))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Deletes a *Price List Record* using the currency code. 
     * Delete a Price Record by Currency Code
     */
    async deletePriceListRecord(requestParameters: DeletePriceListRecordRequest, initOverrides?: RequestInit): Promise<void> {
        await this.deletePriceListRecordRaw(requestParameters, initOverrides);
    }

    /**
     * Deletes a *Price List Record*. Deleting the records does not delete the Price List. Optional parameters can be passed in.
     * Delete a Price List Record
     */
    async deletePriceListRecordsByFilterRaw(requestParameters: DeletePriceListRecordsByFilterRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<NoContent>> {
        if (requestParameters.priceListId === null || requestParameters.priceListId === undefined) {
            throw new runtime.RequiredError('priceListId','Required parameter requestParameters.priceListId was null or undefined when calling deletePriceListRecordsByFilter.');
        }

        const queryParameters: any = {};

        if (requestParameters.variantIdin !== undefined) {
            queryParameters['variant_id:in'] = requestParameters.variantIdin;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
            headerParameters['Accept'] = String(requestParameters.accept);
        }

        if (requestParameters.contentType !== undefined && requestParameters.contentType !== null) {
            headerParameters['Content-Type'] = String(requestParameters.contentType);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-Auth-Token"] = this.configuration.apiKey("X-Auth-Token"); // X-Auth-Token authentication
        }

        const response = await this.request({
            path: `/pricelists/{price_list_id}/records`.replace(`{${"price_list_id"}}`, encodeURIComponent(String(requestParameters.priceListId))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => NoContentFromJSON(jsonValue));
    }

    /**
     * Deletes a *Price List Record*. Deleting the records does not delete the Price List. Optional parameters can be passed in.
     * Delete a Price List Record
     */
    async deletePriceListRecordsByFilter(requestParameters: DeletePriceListRecordsByFilterRequest, initOverrides?: RequestInit): Promise<NoContent> {
        const response = await this.deletePriceListRecordsByFilterRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns a *Price List Record* using the currency code. Optional parameters can be used.
     * Get a Price Record by Currency Code
     */
    async getPriceListRecordRaw(requestParameters: GetPriceListRecordRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<PriceRecordResponse>> {
        if (requestParameters.priceListId === null || requestParameters.priceListId === undefined) {
            throw new runtime.RequiredError('priceListId','Required parameter requestParameters.priceListId was null or undefined when calling getPriceListRecord.');
        }

        if (requestParameters.variantId === null || requestParameters.variantId === undefined) {
            throw new runtime.RequiredError('variantId','Required parameter requestParameters.variantId was null or undefined when calling getPriceListRecord.');
        }

        if (requestParameters.currencyCode === null || requestParameters.currencyCode === undefined) {
            throw new runtime.RequiredError('currencyCode','Required parameter requestParameters.currencyCode was null or undefined when calling getPriceListRecord.');
        }

        const queryParameters: any = {};

        if (requestParameters.include !== undefined) {
            queryParameters['include'] = requestParameters.include;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
            headerParameters['Accept'] = String(requestParameters.accept);
        }

        if (requestParameters.contentType !== undefined && requestParameters.contentType !== null) {
            headerParameters['Content-Type'] = String(requestParameters.contentType);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-Auth-Token"] = this.configuration.apiKey("X-Auth-Token"); // X-Auth-Token authentication
        }

        const response = await this.request({
            path: `/pricelists/{price_list_id}/records/{variant_id}/{currency_code}`.replace(`{${"price_list_id"}}`, encodeURIComponent(String(requestParameters.priceListId))).replace(`{${"variant_id"}}`, encodeURIComponent(String(requestParameters.variantId))).replace(`{${"currency_code"}}`, encodeURIComponent(String(requestParameters.currencyCode))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PriceRecordResponseFromJSON(jsonValue));
    }

    /**
     * Returns a *Price List Record* using the currency code. Optional parameters can be used.
     * Get a Price Record by Currency Code
     */
    async getPriceListRecord(requestParameters: GetPriceListRecordRequest, initOverrides?: RequestInit): Promise<PriceRecordResponse> {
        const response = await this.getPriceListRecordRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns a list of *Price List Records* associated with a *Price List*.
     * Get All Price List Records
     */
    async getPriceListRecordCollectionRaw(requestParameters: GetPriceListRecordCollectionRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<PriceRecordCollectionResponse>> {
        if (requestParameters.priceListId === null || requestParameters.priceListId === undefined) {
            throw new runtime.RequiredError('priceListId','Required parameter requestParameters.priceListId was null or undefined when calling getPriceListRecordCollection.');
        }

        const queryParameters: any = {};

        if (requestParameters.variantIdin !== undefined) {
            queryParameters['variant_id:in'] = requestParameters.variantIdin;
        }

        if (requestParameters.productIdin !== undefined) {
            queryParameters['product_id:in'] = requestParameters.productIdin;
        }

        if (requestParameters.currency !== undefined) {
            queryParameters['currency'] = requestParameters.currency;
        }

        if (requestParameters.page !== undefined) {
            queryParameters['page'] = requestParameters.page;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.include !== undefined) {
            queryParameters['include'] = requestParameters.include;
        }

        if (requestParameters.price !== undefined) {
            queryParameters['price'] = requestParameters.price;
        }

        if (requestParameters.salePrice !== undefined) {
            queryParameters['sale_price'] = requestParameters.salePrice;
        }

        if (requestParameters.retailPrice !== undefined) {
            queryParameters['retail_price'] = requestParameters.retailPrice;
        }

        if (requestParameters.mapPrice !== undefined) {
            queryParameters['map_price'] = requestParameters.mapPrice;
        }

        if (requestParameters.calculatedPrice !== undefined) {
            queryParameters['calculated_price'] = requestParameters.calculatedPrice;
        }

        if (requestParameters.dateCreated !== undefined) {
            queryParameters['date_created'] = (requestParameters.dateCreated as any).toISOString();
        }

        if (requestParameters.dateModified !== undefined) {
            queryParameters['date_modified'] = (requestParameters.dateModified as any).toISOString();
        }

        if (requestParameters.sku !== undefined) {
            queryParameters['sku'] = requestParameters.sku;
        }

        if (requestParameters.skuin) {
            queryParameters['sku:in'] = requestParameters.skuin.join(runtime.COLLECTION_FORMATS["csv"]);
        }

        if (requestParameters.currencyin) {
            queryParameters['currency:in'] = requestParameters.currencyin.join(runtime.COLLECTION_FORMATS["csv"]);
        }

        if (requestParameters.pricemax !== undefined) {
            queryParameters['price:max'] = requestParameters.pricemax;
        }

        if (requestParameters.pricemin !== undefined) {
            queryParameters['price:min'] = requestParameters.pricemin;
        }

        if (requestParameters.salePricemax !== undefined) {
            queryParameters['sale_price:max'] = requestParameters.salePricemax;
        }

        if (requestParameters.salePricemin !== undefined) {
            queryParameters['sale_price:min'] = requestParameters.salePricemin;
        }

        if (requestParameters.retailPricemax !== undefined) {
            queryParameters['retail_price:max'] = requestParameters.retailPricemax;
        }

        if (requestParameters.retailPricemin !== undefined) {
            queryParameters['retail_price:min'] = requestParameters.retailPricemin;
        }

        if (requestParameters.mapPricemax !== undefined) {
            queryParameters['map_price:max'] = requestParameters.mapPricemax;
        }

        if (requestParameters.mapPricemin !== undefined) {
            queryParameters['map_price:min'] = requestParameters.mapPricemin;
        }

        if (requestParameters.calculatedPricemax !== undefined) {
            queryParameters['calculated_price:max'] = requestParameters.calculatedPricemax;
        }

        if (requestParameters.calculatedPricemin !== undefined) {
            queryParameters['calculated_price:min'] = requestParameters.calculatedPricemin;
        }

        if (requestParameters.dateCreatedmax !== undefined) {
            queryParameters['date_created:max'] = requestParameters.dateCreatedmax;
        }

        if (requestParameters.dateCreatedmin !== undefined) {
            queryParameters['date_created:min'] = requestParameters.dateCreatedmin;
        }

        if (requestParameters.dateModifiedmax !== undefined) {
            queryParameters['date_modified:max'] = requestParameters.dateModifiedmax;
        }

        if (requestParameters.dateModifiedmin !== undefined) {
            queryParameters['date_modified:min'] = requestParameters.dateModifiedmin;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.contentType !== undefined && requestParameters.contentType !== null) {
            headerParameters['Content-Type'] = String(requestParameters.contentType);
        }

        if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
            headerParameters['Accept'] = String(requestParameters.accept);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-Auth-Token"] = this.configuration.apiKey("X-Auth-Token"); // X-Auth-Token authentication
        }

        const response = await this.request({
            path: `/pricelists/{price_list_id}/records`.replace(`{${"price_list_id"}}`, encodeURIComponent(String(requestParameters.priceListId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PriceRecordCollectionResponseFromJSON(jsonValue));
    }

    /**
     * Returns a list of *Price List Records* associated with a *Price List*.
     * Get All Price List Records
     */
    async getPriceListRecordCollection(requestParameters: GetPriceListRecordCollectionRequest, initOverrides?: RequestInit): Promise<PriceRecordCollectionResponse> {
        const response = await this.getPriceListRecordCollectionRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns *Price List Records* using the variant ID. Will also contain currency records.
     * Get Price Records by Variant
     */
    async getPriceListRecordsByVariantIdRaw(requestParameters: GetPriceListRecordsByVariantIdRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<PriceRecordCollectionResponse>> {
        if (requestParameters.priceListId === null || requestParameters.priceListId === undefined) {
            throw new runtime.RequiredError('priceListId','Required parameter requestParameters.priceListId was null or undefined when calling getPriceListRecordsByVariantId.');
        }

        if (requestParameters.variantId === null || requestParameters.variantId === undefined) {
            throw new runtime.RequiredError('variantId','Required parameter requestParameters.variantId was null or undefined when calling getPriceListRecordsByVariantId.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
            headerParameters['Accept'] = String(requestParameters.accept);
        }

        if (requestParameters.contentType !== undefined && requestParameters.contentType !== null) {
            headerParameters['Content-Type'] = String(requestParameters.contentType);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-Auth-Token"] = this.configuration.apiKey("X-Auth-Token"); // X-Auth-Token authentication
        }

        const response = await this.request({
            path: `/pricelists/{price_list_id}/records/{variant_id}`.replace(`{${"price_list_id"}}`, encodeURIComponent(String(requestParameters.priceListId))).replace(`{${"variant_id"}}`, encodeURIComponent(String(requestParameters.variantId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PriceRecordCollectionResponseFromJSON(jsonValue));
    }

    /**
     * Returns *Price List Records* using the variant ID. Will also contain currency records.
     * Get Price Records by Variant
     */
    async getPriceListRecordsByVariantId(requestParameters: GetPriceListRecordsByVariantIdRequest, initOverrides?: RequestInit): Promise<PriceRecordCollectionResponse> {
        const response = await this.getPriceListRecordsByVariantIdRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Creates or updates a*Price List Record* using the currency code.
     * Set Price List Record by Currency Code
     */
    async setPriceListRecordRaw(requestParameters: SetPriceListRecordRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<PriceRecordResponse>> {
        if (requestParameters.priceListId === null || requestParameters.priceListId === undefined) {
            throw new runtime.RequiredError('priceListId','Required parameter requestParameters.priceListId was null or undefined when calling setPriceListRecord.');
        }

        if (requestParameters.variantId === null || requestParameters.variantId === undefined) {
            throw new runtime.RequiredError('variantId','Required parameter requestParameters.variantId was null or undefined when calling setPriceListRecord.');
        }

        if (requestParameters.currencyCode === null || requestParameters.currencyCode === undefined) {
            throw new runtime.RequiredError('currencyCode','Required parameter requestParameters.currencyCode was null or undefined when calling setPriceListRecord.');
        }

        if (requestParameters.priceRecord === null || requestParameters.priceRecord === undefined) {
            throw new runtime.RequiredError('priceRecord','Required parameter requestParameters.priceRecord was null or undefined when calling setPriceListRecord.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
            headerParameters['Accept'] = String(requestParameters.accept);
        }

        if (requestParameters.contentType !== undefined && requestParameters.contentType !== null) {
            headerParameters['Content-Type'] = String(requestParameters.contentType);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-Auth-Token"] = this.configuration.apiKey("X-Auth-Token"); // X-Auth-Token authentication
        }

        const response = await this.request({
            path: `/pricelists/{price_list_id}/records/{variant_id}/{currency_code}`.replace(`{${"price_list_id"}}`, encodeURIComponent(String(requestParameters.priceListId))).replace(`{${"variant_id"}}`, encodeURIComponent(String(requestParameters.variantId))).replace(`{${"currency_code"}}`, encodeURIComponent(String(requestParameters.currencyCode))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: UNKNOWN_BASE_TYPEToJSON(requestParameters.priceRecord),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PriceRecordResponseFromJSON(jsonValue));
    }

    /**
     * Creates or updates a*Price List Record* using the currency code.
     * Set Price List Record by Currency Code
     */
    async setPriceListRecord(requestParameters: SetPriceListRecordRequest, initOverrides?: RequestInit): Promise<PriceRecordResponse> {
        const response = await this.setPriceListRecordRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Creates or updates *Price List Records*.   **Required Fields** * currency  **Notes**  * Batch updates are supported by this endpoint, meaning that several price objects can be updated in one request. This allows you to do the same work as many individual requests to singleton endpoints * Batch requests support up to 1,000 items per request. * Up to 2 concurrent batch upsert requests are supported with this API. Running more than the allowed concurrent requests in parallel on the **same store** will cause a 429 error and your additional requests will fail. You are encouraged to run requests sequentially with as many records per request as possible, in order to maximize performance.
     * Upsert Price List Records
     */
    async setPriceListRecordCollectionRaw(requestParameters: SetPriceListRecordCollectionRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<object>> {
        if (requestParameters.priceListId === null || requestParameters.priceListId === undefined) {
            throw new runtime.RequiredError('priceListId','Required parameter requestParameters.priceListId was null or undefined when calling setPriceListRecordCollection.');
        }

        if (requestParameters.priceRecordBatch === null || requestParameters.priceRecordBatch === undefined) {
            throw new runtime.RequiredError('priceRecordBatch','Required parameter requestParameters.priceRecordBatch was null or undefined when calling setPriceListRecordCollection.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (requestParameters.xStrictMode !== undefined && requestParameters.xStrictMode !== null) {
            headerParameters['X-Strict-Mode'] = String(requestParameters.xStrictMode);
        }

        if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
            headerParameters['Accept'] = String(requestParameters.accept);
        }

        if (requestParameters.contentType !== undefined && requestParameters.contentType !== null) {
            headerParameters['Content-Type'] = String(requestParameters.contentType);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-Auth-Token"] = this.configuration.apiKey("X-Auth-Token"); // X-Auth-Token authentication
        }

        const response = await this.request({
            path: `/pricelists/{price_list_id}/records`.replace(`{${"price_list_id"}}`, encodeURIComponent(String(requestParameters.priceListId))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.priceRecordBatch,
        }, initOverrides);

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     * Creates or updates *Price List Records*.   **Required Fields** * currency  **Notes**  * Batch updates are supported by this endpoint, meaning that several price objects can be updated in one request. This allows you to do the same work as many individual requests to singleton endpoints * Batch requests support up to 1,000 items per request. * Up to 2 concurrent batch upsert requests are supported with this API. Running more than the allowed concurrent requests in parallel on the **same store** will cause a 429 error and your additional requests will fail. You are encouraged to run requests sequentially with as many records per request as possible, in order to maximize performance.
     * Upsert Price List Records
     */
    async setPriceListRecordCollection(requestParameters: SetPriceListRecordCollectionRequest, initOverrides?: RequestInit): Promise<object> {
        const response = await this.setPriceListRecordCollectionRaw(requestParameters, initOverrides);
        return await response.value();
    }

}

/**
    * @export
    * @enum {string}
    */
export enum GetPriceListRecordIncludeEnum {
    BulkPricingTiers = 'bulk_pricing_tiers',
    Sku = 'sku'
}
/**
    * @export
    * @enum {string}
    */
export enum GetPriceListRecordCollectionIncludeEnum {
    BulkPricingTiers = 'bulk_pricing_tiers',
    Sku = 'sku'
}
